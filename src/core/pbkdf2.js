const { strToUint8Array, hexToArrayBuffer, arrayBufferToHex } = require('../util/common');

/**
 *
 * @param {string} rawKey Passphrase
 * @param {number} iterations
 * @param {null | Uint8Array } salt optional salt from previously derived key
 *
 * @returns {DerivedKey}
 */
async function deriveKey(
  rawKey,
  iterations = 100000, //=1e6
  salt
) {
  const crypto = window.crypto;
  const masterKey = await crypto.subtle.importKey(
    'raw',
    strToUint8Array(rawKey),
    { name: 'PBKDF2' },
    false,
    ['deriveKey']
  );

  salt = salt || crypto.getRandomValues(new Uint8Array(32));
  const params = {
    name: 'PBKDF2',
    hash: { name: 'SHA-256' },
    salt,
    iterations
  };

  const key = await crypto.subtle.deriveKey(
    params,
    masterKey,
    { name: 'AES-GCM', length: 256 },
    true,
    ['encrypt', 'decrypt']
  );

  const keyBytes = await crypto.subtle.exportKey('raw', key);
  return {
    key: keyBytes,
    salt
  };
}

/**
 * Returns a PBKDF2 derived key from supplied password.
 *
 * @param   {String} plain - Passphrase to be hashed using key the derivation function.
 * @returns {String} Raw derived key bytes.
 *
 * @example
 *   const key = await pbkdf2('randompass'); // eg 'djAxBRKXWNWPyXgpKWHld8SWJA9CQFmLyMbNet7Rle5RLKJAkBCllLfM6tPFa7bAis0lSTiB'
 */
 async function pbkdf2(plain) {
  const { key, salt } = await deriveKey(plain);
  const keyHex = arrayBufferToHex(key);
  const saltHex = arrayBufferToHex(salt);
  return saltHex + keyHex;
}

/**
 * Verifies whether the supplied passphrase matches the passphrase previously used to generate the key.
 *
 * @param   {String}  key - Key previously generated by pbkdf2().
 * @param   {String}  rawKey - Passphrase to be matched against previously derived key.
 * @returns {boolean} Whether passphrase matches key.
 *
 * @example
 *   const match = await pbkdf2Verify(key, 'randompass'); // true
 */
async function verifyRaw(
  key,
  rawKey
) {
  const iterations = 100000;
  //@ts-ignore
  const saltArray = key
    .slice(0, 64)
    .match(/.{2}/g)
    .map(b => parseInt(b, 16));

  const salt = new Uint8Array(saltArray);
  const keyHex = key.slice(64);
  const { key: derivedKey } = await deriveKey(rawKey, iterations, salt);
  const derivedKeyHex = arrayBufferToHex(derivedKey);
  return derivedKeyHex === keyHex;
}

async function extractKey(encodedKey) {
  const crypto = window.crypto;
  const keyBuffer = hexToArrayBuffer(encodedKey.slice(64));
  const key = await crypto.subtle.importKey(
    'raw',
    keyBuffer,
    { name: 'AES-GCM' },
    true,
    ['encrypt', 'decrypt']
  );

  return key;
}

module.exports = {
  extractKey,
  verifyRaw,
  pbkdf2
}
