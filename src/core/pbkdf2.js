const { strToUint8Array, hexToArrayBuffer, arrayBufferToHex } = require('../util/common');
const crypto = window.crypto;
const AES = 'AES-GCM';
const PBKDF2 = 'PBKDF2';
/**
 *
 * @param {string} rawKey Passphrase
 * @param {number} iterations
 * @param {null | Uint8Array } salt optional salt from previously derived key
 *
 * @returns {DerivedKey}
 */
async function deriveKey(
  rawKey,
  iterations = 100000, //=1e6
  salt
) {
  const importKeyOpts = ['raw', strToUint8Array(rawKey), { name: PBKDF2 }, false, ['deriveKey']]
  const masterKey = await crypto.subtle.importKey(...importKeyOpts);

  salt = salt || crypto.getRandomValues(new Uint8Array(32));
  const params = {
    name: PBKDF2,
    hash: { name: 'SHA-256' },
    salt,
    iterations
  };

  const deriveKeyOpts = [params, masterKey, {name: AES, length: 256}, true, ['encrypt', 'decrypt']];
  const key = await crypto.subtle.deriveKey(...deriveKeyOpts);
  const keyBytes = await crypto.subtle.exportKey('raw', key);
  return {
    key: keyBytes,
    salt
  };
}

/**
 * Returns a PBKDF2 derived key from supplied password.
 *
 * @param   {String} plain - Passphrase to be hashed using key the derivation function.
 * @returns {String} Raw derived key bytes.
 *
 * @example
 *   const key = await pbkdf2('randompass'); // eg 'djAxBRKXWNWPyXgpKWHld8SWJA9CQFmLyMbNet7Rle5RLKJAkBCllLfM6tPFa7bAis0lSTiB'
 */
 async function pbkdf2(plain) {
  const { key, salt } = await deriveKey(plain);
  const keyHex = arrayBufferToHex(key);
  const saltHex = arrayBufferToHex(salt);
  return saltHex + keyHex;
}

/**
 * Verifies whether the supplied passphrase matches the passphrase previously used to generate a key.
 *
 * @param   {String}  key - Key previously generated by pbkdf2().
 * @param   {String}  rawKey - Passphrase to be matched against previously derived key.
 * @returns {boolean} Whether rawKey(passphrase) matches key.
 *
 * @example
 *   const match = await pbkdf2Verify(key, 'randompass'); // true
 */
async function verifyRaw(
  key,
  rawKey
) {
  const iterations = 100000;
  const saltArray = key
    .slice(0, 64)
    .match(/.{2}/g)
    .map(b => parseInt(b, 16));
  const salt = new Uint8Array(saltArray);
  const keyHex = key.slice(64);
  const deriveKeyOpts = [rawKey, iterations, salt];
  const { key: derivedKey } = await deriveKey(...deriveKeyOpts);
  const derivedKeyHex = arrayBufferToHex(derivedKey);
  return derivedKeyHex === keyHex;
}

async function extractKey(encodedKey) {
  const keyBuffer = hexToArrayBuffer(encodedKey.slice(64));
  const importKeyOpts = ['raw', keyBuffer, {name: AES}, true, ['encrypt', 'decrypt']];
  const key = await crypto.subtle.importKey(...importKeyOpts);
  return key;
}

module.exports = {
  extractKey,
  verifyRaw,
  pbkdf2
}
